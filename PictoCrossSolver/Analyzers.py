import re
from PictoCrossSolver.Elements import Zone, Mark
from typing import List

class RegexBuilder:
    """
    Builds regular expressions out of arrays of hints that can be applied progressively
    to data arrays.

    The concept matches observational patterns found when solving pictocrosses trying to
    find the largest match for any one item. By looping all hints, you can generate a 
    regular expression that is able to match each parts of the hint sequence in a greedy
    manner while other parts are matched lazilly.
    """

    @staticmethod
    def getRegularExpressionParts(hints: List[int], greedyHintIndex: int) -> List[str]:
        """
        Produces the regular expressions parts based on hints and greedy hint index specifier
        but doesn't produce the prefix or suffix, this has to be added by the parents calling this

        @param List[int] hints to generate expression for
        @param int greedyHintIndex specifying which hint should be greedy in the regular expression

        @return List[str]
        """

        # Contains all parts of the regex as string blocks
        parts = []

        # For each hint in reverse order
        for hintIndex, hint in enumerate(hints):

            # Check for greedy or lazy matching
            if hintIndex == greedyHintIndex:
                lazy = ""
            else:
                lazy = "?"

            # Add to the regex
            parts.append(f"(?P<hint{hintIndex}>(a|f){{{hint},}}{lazy})")
            
            # If there are more items after this one, add a separator matcher
            if len(hints) > (hintIndex + 1):
                parts.append(f"(?P<sep{hintIndex}>(a|c){{1,}}?)")

        return parts

    @staticmethod
    def getForwardRegularExpression(hints: List[int], greedyHintIndex: int) -> str:
        """
        Produce a regular expression based on hints in a forward fashion

        @param List[int] hints to generate expression for
        @param int greedyHintIndex specifying which hint should be greedy in the regular expression

        @return str
        """

        # Contains all parts of the regex as string blocks
        parts = []

        # Add the lazy prefix
        parts.append(f"(?P<prefix>(a|c)*?)")

        # Add all parts next
        parts = parts + RegexBuilder.getRegularExpressionParts(hints, greedyHintIndex)

        # Add the greedy suffix
        parts.append(f"(?P<suffix>(a|c)*)")

        # Return reversed and joined
        return "".join(parts)


    @staticmethod
    def getBackwardRegularExpression(hints: List[int], greedyHintIndex: int) -> str:
        """
        Produce a regular expression based on hints but in a backwards fashion

        @param List[int] hints to generate expression for
        @param int greedyHintIndex specifying which hint should be greedy in the regular expression

        @return str
        """

        # Contains all parts of the regex as string blocks
        parts = []

        # Add the greedy prefix
        parts.append(f"(?P<prefix>(a|c)*)")

        # Add all parts next
        parts = parts + RegexBuilder.getRegularExpressionParts(hints, greedyHintIndex)

        # Add the lazy suffix
        parts.append(f"(?P<suffix>(a|c)*?)")

        # Return reversed and joined
        return "".join(parts[::-1])


class ZoneSerializer:
    """
    The ZoneSerializer takes the Marks of a Zone into a list of a, b and m letters
    that are used by the RegexZoneAnalyzer against generated regular expressions generated by 
    the RegexBuilder
    """

    @staticmethod
    def serialize(zone: Zone) -> str:
        """
        Serializes the Zone into a list of values usable in generated regular expressions

        @param Zone zone to serialize

        @return str
        """

        results = []
        for mark in zone.getMarks():
            if mark.isFilled():
                results.append("f")
            elif mark.isCrossed():
                results.append("c")
            else:
                results.append("a")
        
        return "".join(results)

class RegexZoneAnalyzer:
    """
    The RegexZoneAnalyzer is used to apply a regular expression set against a serialized
    pattern and return the slice to extract from the Zone that this information came
    from originaly.
    """

    @staticmethod
    def analyze(pattern: str, matcher: str, hint: int) -> slice:
        """
        Runs the analysis on the pattern that comes from a Zone and was serialized
        and uses the matcher against it and returns a slice representing the hit zone.

        @param str pattern to match against
        @param str matcher is the regex to apply
        @param int hint is the index of the hint to extract

        @return slice
        """

        # Run the regular expression to get matches for named groups
        try:
            matches = re.fullmatch(matcher, pattern).groupdict()
        except (NameError, AttributeError):
            return slice(0)

        # Add up each length to get the start index and stop index of zones to bundle
        startIndex = 0
        for match in matches:
            if match == f'hint{hint}':
                break
            else:
                startIndex += len(matches[match])
        stopIndex = startIndex + len(matches[f'hint{hint}'])

        # Bundle up the indexes into a slice, includes the last character
        return slice(startIndex, stopIndex)

class HintIntersectionRegexAnalyzer:
    """
    This is an added layer over the RegexZoneAnalyzer that runs both a straightforward version of the regex
    over the pattern and then a reversed one that will return the real slice that applies.

    The reason for this is that in certain scenarios with lots of hints, sometimes, the single straigthforward
    analysis will not yield the proper slice because if you reverse the matching the hint falls into another
    slice. This means that the hint cannot be properly placed.

    A good example of this is:

    (3,2,2) => aaaaaaaaacff

    If you try to match on this, it says that hint #3 (the second 2), can be set into the last two "aa" 
    before the "bmm", but in fact, the hint #3 is already filled on the "bmm" portion. By running a reverse
    check on

    (2,2,3) => ffcaaaaaaaaa

    You get a match that is totally different and now "mm" matches hint #3 that comes first. This tells us that
    we cannot properly trust the initial forward check. In the current case, the slice retrieve will be non 
    ambiguous because the hint fits in the first "mm" zone. If the test was:

    (2,2,3) => aaaaaaaaaaaa

    It wouldn't work because slice(0, 2, 1) in reversed mode or slice(10, 12, 1) doesn't match the forward search
    that would have yielded slice(7, 9, 1). There would be no crossover and everything would be ambiguous. In that
    case the analyzer would return no slice possible.
    """

    @staticmethod
    def analyze(zone: Zone, hintIndex: int) -> slice:
        """
        Runs the analysis on the pattern that comes from a Zone and was serialized
        and uses the matcher against it and returns a slice representing the hit zone.

        @param Zone zone to analyze
        @param int hintIndex to analyze

        @return slice
        """

        # Get the serialized versions
        forwardPattern = ZoneSerializer.serialize(zone)
        backwardPattern = forwardPattern[::-1]

        # Get the regular expressions forward and reverse
        forwardExpression = RegexBuilder.getForwardRegularExpression(zone.getHints(), hintIndex)
        backwardExpression = RegexBuilder.getBackwardRegularExpression(zone.getHints(), hintIndex)

        # Get the results both for forward and backward setup
        forwardSlice = RegexZoneAnalyzer.analyze(forwardPattern, forwardExpression, hintIndex)
        backwardSlice = RegexZoneAnalyzer.analyze(backwardPattern, backwardExpression, hintIndex)

        # If the forward or backward slice is invalid, yield nothing
        if forwardSlice.start == None or forwardSlice.stop == None:
            return None
        if backwardSlice.start == None or backwardSlice.stop == None:
            return None

        # Reverse the backward slice
        backwardSlice = slice(
            len(zone.getMarks()) - backwardSlice.stop,
            len(zone.getMarks()) - backwardSlice.start
        )
        
        # Find the intersection between the slice to create a new slice
        # Do this using sets and ranges
        forwardSet = set(range(forwardSlice.start, forwardSlice.stop))
        backwardSet = set(range(backwardSlice.start, backwardSlice.stop))
        intersection = forwardSet.intersection(backwardSet)

        # If there is an intersection, return the best case for the intersection
        if len(intersection) > 0:
            return slice(
                min(value for value in intersection),
                max(value for value in intersection) + 1
            )
        
        # There are no intersections, check if there is a slice that has only filled marks matching the hint size
        # If there are enough marks it is safe to assume that this is the right block
        forwardSliceFilledMarks = len(list(mark for mark in zone.getMarks()[forwardSlice] if mark.isFilled()))
        backwardSliceFilledMarks = len(list(mark for mark in zone.getMarks()[backwardSlice] if mark.isFilled()))
        if forwardSliceFilledMarks == 0 and backwardSliceFilledMarks == zone.getHints()[hintIndex]:
            return backwardSlice
        elif backwardSliceFilledMarks == 0 and forwardSliceFilledMarks == zone.getHints()[hintIndex]:
            return forwardSlice

class HintSharesFilledMarksWithAnotherHint:
    """
    This is an added layer over the HintCrossoverRegexAnalyzer that runs all hints to gather their slices and
    then takes the suggested hintIndex to find shared marks with other hints.

    This analyzer is used to prevent scenarios like the following:

    (3,1,1) => aaaaafafaaaa

    If you try to match on this, it says that hint #3 (the second 1), can be set into the last 5 "faaaa" but in fact
    this is incorrect as the 2nd "f" could be part of the hint #1: 3.
    """

    @staticmethod
    def analyze(zone: Zone, hintIndex: int) -> slice:
        """
        Runs the analysis on the pattern that comes from a Zone and was serialized
        and uses the matcher against it and returns a slice representing the hit zone.

        @param Zone zone to analyze
        @param int hintIndex to analyze

        @return slice
        """

        # Gather all slices for hints
        hintSlices = {}
        for innerHintIndex, hint in enumerate(zone.getHints()):
            hintSlices[innerHintIndex] = HintIntersectionRegexAnalyzer.analyze(zone, innerHintIndex)

        # Compare the master slice with all other slices to find potential intersections of filled slices
        masterSlice = hintSlices[hintIndex]
        if masterSlice == None:
            return None
        masterSet = set(range(masterSlice.start, masterSlice.stop))
        for otherSliceIndex in hintSlices.keys():
            if otherSliceIndex == hintIndex:
                continue
            otherSlice = hintSlices[otherSliceIndex]
            if otherSlice == None:
                continue
            otherSet = set(range(otherSlice.start, otherSlice.stop))
            intersection = otherSet.intersection(masterSet)
            if len(intersection) == 0:
                continue
            intersectionSlice = slice(
                min(value for value in intersection),
                max(value for value in intersection) + 1
            )
            filledMarksInRange = len(list(mark for mark in zone.getMarks()[intersectionSlice] if mark.isFilled()))
            masterHint = zone.getHints()[hintIndex]
            otherHint = zone.getHints()[otherSliceIndex]
            if filledMarksInRange and masterHint != otherHint:
                return True

class HintUnionRegexAnalyzer:
    """
    This is an added layer over the RegexZoneAnalyzer that runs both a straightforward version of the regex
    over the pattern and then a reversed one that will return the union of both slices.

    On the contrary of HintIntersectionRegexAnalyzer, this analyzer gets all of the potential zones instead of
    only the possible zones that intersect. This can be used to get all other zones not covered by any hint
    placement at all such as in the CrossMarksUnreachableByAnyHint solver.

    Example:

    (3,1,1) => "??XOOOXOX??X" should yield that the first 2 "??" are unreachable because the hint #1 is already
    fulfilled.
    """

    @staticmethod
    def analyze(zone: Zone, hintIndex: int) -> slice:
        """
        Runs the analysis on the pattern that comes from a Zone and was serialized
        and uses the matcher against it and returns a slice representing the hit zone.

        @param Zone zone to analyze
        @param int hintIndex to analyze

        @return slice
        """

        # Get the serialized versions
        forwardPattern = ZoneSerializer.serialize(zone)
        backwardPattern = forwardPattern[::-1]

        # Get the regular expressions forward and reverse
        forwardExpression = RegexBuilder.getForwardRegularExpression(zone.getHints(), hintIndex)
        backwardExpression = RegexBuilder.getBackwardRegularExpression(zone.getHints(), hintIndex)

        # Get the results both for forward and backward setup
        forwardSlice = RegexZoneAnalyzer.analyze(forwardPattern, forwardExpression, hintIndex)
        backwardSlice = RegexZoneAnalyzer.analyze(backwardPattern, backwardExpression, hintIndex)

        # If the forward or backward slice is invalid, yield nothing
        if forwardSlice.start == None or forwardSlice.stop == None:
            return slice(0, len(zone.getMarks()))
        if backwardSlice.start == None or backwardSlice.stop == None:
            return slice(0, len(zone.getMarks()))

        # Reverse the backward slice
        backwardSlice = slice(
            len(zone.getMarks()) - backwardSlice.stop,
            len(zone.getMarks()) - backwardSlice.start
        )

        # Union both slices and return a huge slice that covers both
        forwardSet = set(range(forwardSlice.start, forwardSlice.stop))
        backwardSet = set(range(backwardSlice.start, backwardSlice.stop))
        union = forwardSet.union(backwardSet)
        resultingSlice = slice(
            min(value for value in union),
            max(value for value in union) + 1
        )

        # Find out if there are contiguous filled marks in that slice, if so, we should adjust the slice
        # to return only potential marks around those marks and not the full zone.
        # Make sure that the filled marks in this hint are not shared with other hints!
        resultingFilledMarks = list(mark for mark in zone.getMarks()[resultingSlice] if mark.isFilled())
        if len(resultingFilledMarks) == 0 or not HintMarksContiguousAnalyzer.analyze(zone, resultingFilledMarks) or HintSharesFilledMarksWithAnotherHint.analyze(zone, hintIndex):
            return resultingSlice
        
        # Because all filled marks are contiguous, we should assume that the hint falls directly
        # around these marks and not on the full slice

        # First, find the slice that corresponds to the filled marks
        filledMarksLen = len(resultingFilledMarks)
        hint = zone.getHints()[hintIndex]
        missingMarksLen = hint - filledMarksLen
        filledMarksSlice = None
        for markIndex, mark in enumerate(zone.getMarks()):
            if mark is resultingFilledMarks[0]:
                filledMarksSlice = slice(markIndex, markIndex + filledMarksLen)
                break

        # Next, find the preceding and following mark slices
        precedingSlice = slice(max(resultingSlice.start, filledMarksSlice.start - missingMarksLen), filledMarksSlice.start)
        followingSlice = slice(filledMarksSlice.stop, min(resultingSlice.stop, filledMarksSlice.stop + missingMarksLen))
        
        # Send back a new slice combining preceding, filled and following marks
        return slice(precedingSlice.start, followingSlice.stop)

        


class HintMarksContiguousAnalyzer:
    """
    This is analyzer takes a series of marks from a zone and ensures they are contiguous. This is necessary in
    some solvers like the CrossMarksOutsideOfSolvedHintZonesSolver to ensure that the filled marks that it found
    are contiguous and not split by other ambiguous marks.

    Example:

    (3,3) => "X?OO???O????" should yield that the filled zones are not contiguous.
    """

    @staticmethod
    def analyze(zone: Zone, searchedMarks: List[Mark]) -> bool:
        """
        Runs the analysis on the zone to find the marks and ensure they are contiguous.

        @param Zone zone to analyze
        @param List[Mark] searchedMarks to find

        @return bools
        """

        # Find the indexes of each mark
        indexes = set()
        for zoneMarkIndex, zoneMark in enumerate(zone.getMarks()):
            for searchedMark in searchedMarks:
                if searchedMark is zoneMark:
                    indexes.update({zoneMarkIndex})
        
        # Find the min, the max and return true if the different is not 0 when removing the len of marks searched for
        minIndex = min(value for value in indexes)
        maxIndex = max(value for value in indexes) + 1
        return maxIndex - minIndex - len(searchedMarks) == 0
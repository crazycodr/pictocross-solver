import re
from PictoCrossSolver.PictoCross import Zone

class RegexBuilder:
    """
    Builds regular expressions out of arrays of hints that can be applied progressively
    to data arrays.

    The concept matches observational patterns found when solving pictocrosses trying to
    find the largest match for any one item. By looping all hints, you can generate a 
    regular expression that is able to match each parts of the hint sequence in a greedy
    manner while other parts are matched lazilly.
    """

    @staticmethod
    def getRegularExpressions(hints: list) -> list:
        """
        Produces the regular expressions based on hints.
        """

        # Produce a regex for each hint
        regexes = []
        for hintIndex, dummy in enumerate(hints):

            # Setup the prefix to catch any ambiguous at the beginning of the looked at sequence 
            regex = f"(?P<prefix>(a|b)*?)"

            # Supplement the regex for each hint
            for hintIndexInner, hint in enumerate(hints):

                # If both indexes match, make it greedy, else, make it lazy
                if hintIndex == hintIndexInner:
                    lazy = ""
                else:
                    lazy = "?"

                # Add to the regex
                regex += f"(?P<hint{hintIndexInner}>(a|m){{{hint},}}{lazy})"
                
                # If there are more items after this one, add a separator matcher
                if len(hints) > (hintIndexInner + 1):
                    regex += f"(?P<sep{hintIndexInner}>(a|b){{1,}}?)"
            
            # Supplement with a suffix to catch any ambiguous at the end of the looked at sequence 
            regex += f"(?P<suffix>(a|b)*?)"

            # Save into the results for printout
            regexes.append(regex)

        return regexes

class ZoneSerializer:
    """
    The ZoneSerializer takes the Marks of a Zone into a list of a, b and m letters
    that are used by the ZoneAnalyzer against generated regular expressions generated by 
    the RegexBuilder
    """

    @staticmethod
    def serialize(zone: Zone) -> str:
        """
        Serializes the Zone into a list of values usable in generated regular expressions
        """

        results = []
        for mark in zone.getMarks():
            if mark.isFilled():
                results.append("m")
            elif mark.isCrossed():
                results.append("b")
            else:
                results.append("a")
        
        return "".join(results)

class ZoneAnalyzer:
    """
    The ZoneAnalyzer is used to apply a regular expression set against a serialized
    pattern and return the slice to extract from the Zone that this information came
    from originaly.
    """

    @staticmethod
    def analyze(pattern: str, matcher: str, hint: int) -> slice:
        """
        Runs the analysis on the pattern that comes from a Zone and was serialized
        and uses the matcher against it and returns a slice representing the hit zone.

        @param str pattern to match against
        @param str matcher is the regex to apply
        @param int hint is the index of the hint to extract

        @return slice
        """

        # Run the regular expression to get matches for named groups
        try:
            matches = re.match(matcher, pattern).groupdict()
        except (NameError, AttributeError):
            return slice(0)

        # Add up each length to get the start index and stop index of zones to bundle
        startIndex = len(matches['prefix'])
        for index in range(hint):
            startIndex += len(matches[f'hint{index}'])
            startIndex += len(matches[f'sep{index}'])
        stopIndex = startIndex + len(matches[f'hint{hint}'])

        # Bundle up the indexes into a slice, includes the last character
        return slice(startIndex, stopIndex)
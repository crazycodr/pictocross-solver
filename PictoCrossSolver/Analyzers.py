import re
from PictoCrossSolver.PictoCross import Zone

class RegexBuilder:
    """
    Builds regular expressions out of arrays of hints that can be applied progressively
    to data arrays.

    The concept matches observational patterns found when solving pictocrosses trying to
    find the largest match for any one item. By looping all hints, you can generate a 
    regular expression that is able to match each parts of the hint sequence in a greedy
    manner while other parts are matched lazilly.
    """

    @staticmethod
    @DeprecationWarning
    def getRegularExpressions(hints: list) -> list:
        """
        Produces the regular expressions based on hints.
        """

        # Produce a regex for each hint
        regexes = []
        for hintIndex, dummy in enumerate(hints):
            regexes.append(RegexBuilder.getForwardRegularExpression(hints, hintIndex))

        return regexes

    @staticmethod
    def getRegularExpressionParts(hints: list, greedyHintIndex: int) -> list:
        """
        Produces the regular expressions parts based on hints and greedy hint index specifier
        but doesn't produce the prefix or suffix, this has to be added by the parents calling this
        """

        # Contains all parts of the regex as string blocks
        parts = []

        # For each hint in reverse order
        for hintIndex, hint in enumerate(hints):

            # Check for greedy or lazy matching
            if hintIndex == greedyHintIndex:
                lazy = ""
            else:
                lazy = "?"

            # Add to the regex
            parts.append(f"(?P<hint{hintIndex}>(a|m){{{hint},}}{lazy})")
            
            # If there are more items after this one, add a separator matcher
            if len(hints) > (hintIndex + 1):
                parts.append(f"(?P<sep{hintIndex}>(a|b){{1,}}?)")

        return parts

    @staticmethod
    def getForwardRegularExpression(hints: list, greedyHintIndex: int) -> str:
        """
        Produce a regular expression based on hints in a forward fashion
        """

        # Contains all parts of the regex as string blocks
        parts = []

        # Add the lazy prefix
        parts.append(f"(?P<prefix>(a|b)*?)")

        # Add all parts next
        parts = parts + RegexBuilder.getRegularExpressionParts(hints, greedyHintIndex)

        # Add the greedy suffix
        parts.append(f"(?P<suffix>(a|b)*)")

        # Return reversed and joined
        return "".join(parts)


    @staticmethod
    def getBackwardRegularExpression(hints: list, greedyHintIndex: int) -> str:
        """
        Produce a regular expression based on hints but in a backwards fashion
        """

        # Contains all parts of the regex as string blocks
        parts = []

        # Add the greedy prefix
        parts.append(f"(?P<prefix>(a|b)*)")

        # Add all parts next
        parts = parts + RegexBuilder.getRegularExpressionParts(hints, greedyHintIndex)

        # Add the lazy suffix
        parts.append(f"(?P<suffix>(a|b)*?)")

        # Return reversed and joined
        return "".join(parts[::-1])


class ZoneSerializer:
    """
    The ZoneSerializer takes the Marks of a Zone into a list of a, b and m letters
    that are used by the RegexZoneAnalyzer against generated regular expressions generated by 
    the RegexBuilder
    """

    @staticmethod
    def serialize(zone: Zone) -> str:
        """
        Serializes the Zone into a list of values usable in generated regular expressions
        """

        results = []
        for mark in zone.getMarks():
            if mark.isFilled():
                results.append("m")
            elif mark.isCrossed():
                results.append("b")
            else:
                results.append("a")
        
        return "".join(results)

class RegexZoneAnalyzer:
    """
    The RegexZoneAnalyzer is used to apply a regular expression set against a serialized
    pattern and return the slice to extract from the Zone that this information came
    from originaly.
    """

    @staticmethod
    def analyze(pattern: str, matcher: str, hint: int) -> slice:
        """
        Runs the analysis on the pattern that comes from a Zone and was serialized
        and uses the matcher against it and returns a slice representing the hit zone.

        @param str pattern to match against
        @param str matcher is the regex to apply
        @param int hint is the index of the hint to extract

        @return slice
        """

        # Run the regular expression to get matches for named groups
        try:
            matches = re.match(matcher, pattern).groupdict()
        except (NameError, AttributeError):
            return slice(0)

        # Add up each length to get the start index and stop index of zones to bundle
        startIndex = 0
        for match in matches:
            if match == f'hint{hint}':
                break
            else:
                startIndex += len(matches[match])
        stopIndex = startIndex + len(matches[f'hint{hint}'])

        # Bundle up the indexes into a slice, includes the last character
        return slice(startIndex, stopIndex)

class HintCrossoverRegexAnalyzer:
    """
    This is an added layer over the RegexZoneAnalyzer that runs both a straightforward version of the regex
    over the pattern and then a reversed one that will return the real slice that applies.

    The reason for this is that in certain scenarios with lots of hints, sometimes, the single straigthforward
    analysis will not yield the proper slice because if you reverse the matching the hint falls into another
    slice. This means that the hint cannot be properly placed.

    A good example of this is:

    (3,2,2) => aaaaaaaaabmm

    If you try to match on this, it says that hint #3 (the second 2), can be set into the last two "aa" 
    before the "bmm", but in fact, the hint #3 is already filled on the "bmm" portion. By running a reverse
    check on

    (2,2,3) => mmbaaaaaaaaa

    You get a match that is totally different and now "mm" matches hint #3 that comes first. This tells us that
    we cannot properly trust the initial forward check. In the current case, the slice retrieve will be non 
    ambiguous because the hint fits in the first "mm" zone. If the test was:

    (2,2,3) => aaaaaaaaaaaa

    It wouldn't work because slice(0, 2, 1) in reversed mode or slice(10, 12, 1) doesn't match the forward search
    that would have yielded slice(7, 9, 1). There would be no crossover and everything would be ambiguous. In that
    case the analyzer would return no slice possible.
    """

    @staticmethod
    def analyze(zone: Zone, hintIndex: int) -> slice:
        """
        Runs the analysis on the pattern that comes from a Zone and was serialized
        and uses the matcher against it and returns a slice representing the hit zone.

        @param str pattern to match against
        @param str matcher is the regex to apply
        @param int hint is the index of the hint to extract

        @return slice
        """

        # Get the serialized versions
        forwardPattern = ZoneSerializer.serialize(zone)
        backwardPattern = forwardPattern[::-1]

        # Get the regular expressions forward and reverse
        forwardExpression = RegexBuilder.getForwardRegularExpression(zone.getHints(), hintIndex)
        backwardExpression = RegexBuilder.getBackwardRegularExpression(zone.getHints(), hintIndex)

        # Get the results both for forward and backward setup
        forwardSlice = RegexZoneAnalyzer.analyze(forwardPattern, forwardExpression, hintIndex)
        backwardSlice = RegexZoneAnalyzer.analyze(backwardPattern, backwardExpression, hintIndex)

        # Reverse the backward slice
        backwardSlice = slice(
            len(zone.getMarks()) - backwardSlice.stop,
            len(zone.getMarks()) - backwardSlice.start
        )
        
        # Find the intersection between the slice to create a new slice
        # Do this using sets and ranges
        forwardSet = set(range(forwardSlice.start, forwardSlice.stop))
        backwardSet = set(range(backwardSlice.start, backwardSlice.stop))
        intersection = forwardSet.intersection(backwardSet)

        # If there is an intersection, return the best case for the intersection
        if len(intersection) > 0:
            return slice(
                min(value for value in intersection),
                max(value for value in intersection) + 1
            )
        
        # There are no intersections, check if there is a slice that has only filled marks
        forwardSliceFilledMarks = len(list(mark for mark in zone.getMarks()[forwardSlice] if mark.isFilled()))
        backwardSliceFilledMarks = len(list(mark for mark in zone.getMarks()[backwardSlice] if mark.isFilled()))
        if forwardSliceFilledMarks == 0 and backwardSliceFilledMarks != 0:
            return backwardSlice
        elif backwardSliceFilledMarks == 0 and forwardSliceFilledMarks != 0:
            return forwardSlice